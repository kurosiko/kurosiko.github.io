<!DOCTYPE html>
<html>
  <head>
    <title>kurosikoのソフト配布ページ</title>
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/base16/railscasts.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
      /* 全体のスタイル */
      body {
        font-family: Arial, sans-serif;
        background-color: #f2f2f2;
        color: #333333;
        margin: 0;
        padding: 0;
      }
      .center {
        text-align: center;
      }
      h1, h2, h3, a {
        margin-bottom: 1em;
        margin-left: 1rem;
      }
      h1 {
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
      }
      h2 {
        font-size: 2rem;
        font-weight: bold;
        text-align: center;
      }
      h3 {
        font-size: 1.5rem;
        font-weight: bold;
        text-align: center;
      }
      a {
        font-size: 1.2rem;
        font-weight: bold;
        color: #89ccf1;
        text-decoration: none;
      }
      p {
        text-align: center;
      }
      pre {
        padding: 1em;
        margin: 0 0 1.5em;
        border: solid 1px #4d4d4d;
      }
    </style>
  </head>
  <body>
    <h1>kurosikoのソフト配布ページ</h1>
    <h2>VideoFetcher</h2>
    <h3>Latest</h3>
    <p><a href="https://github.com/kurosiko/Kuros-VideoFetcher/releases/tag/v1.3">VideoFetcher v1.3</a></p>
    <h3>Older Releases</h3>
    
    <p> <a href="https://github.com/kurosiko/Kuros-VideoFetcher/releases/tag/v1.2">VideoFetcher v1.2</a>
        <br>
        <a href="https://github.com/kurosiko/Kuros-VideoFetcher/releases/tag/v1.1">VideoFetcher v1.1</a>
        <br>
        <a href="https://github.com/kurosiko/Kuros-VideoFetcher/releases/tag/v1.0">VideoFetcher v1.0</a>
        <br>
        <a href="https://github.com/kurosiko/Kuros-VideoFetcher/releases/tag/v0.7">VideoFetcher v0.7</a>
        <br>  
        <a href="https://mega.nz/file/kflTiZiC#DcLNwQi_VeFE1w2d-PNSvOSZY2QJof0xWcbOMA5fkIk">VideoFetcher v0.6</a>
        <br>
        <a href="https://mega.nz/file/lO9DnA4C#bEgnN6MvsFXleEyWSdNVZnJC_T1yN0KAtNJaCrZZqcc">VideoFetcher v0.5</a>
        <br>
        <a href="https://mega.nz/file/YCM2SabK#QidcaCVaUqUfyUwpPePVAjAVXGQEzJxB9_SN_cLErpo">VideoFetcher v0.4</a>
        <br>
        <a href="https://mega.nz/file/NKsV2J7T#6U5tkJLA9srJ_5as16e0hyAK7LZ6qZTKwBKll_hIn20">VideoFetcher v0.3</a>
        <br>
        <a href="https://mega.nz/file/lSUh0TRT#qsJZJn9ydhwrX5puLzfuJusTSl1t5ZQvvSkkd0tXX8o">VideoFetcher v0.2</a>
        <br>
        <a href="https://mega.nz/file/ZSsEzaAT#ITvBHQva-77ouruS6fp6Zl63jxJT7Fz5N7iIi7Z-kFk">VideoFetcher v0.1</a>
    </p>
    <h3>kurosiko</h3>
    <p><a href="https://www.youtube.com/channel/UCkbPdwURHuIG63f5ZTj3fjw">YouTube</a>
      <a href="https://twitter.com/kurosiko">Twitter</a>
      <a href="https://github.com/kurosiko">GitHub</a>
    </p>
    <pre>
    <code>
      import tkinter
      from tkinter import filedialog,messagebox
      import ctypes
      import customtkinter
      import os
      import pystray
      import configparser
      import webbrowser
      import PIL.Image
      import PIL.ImageTk
      import threading
      import io
      import requests
      import win11toast
      import math
      import tkinterdnd2
      from yt_dlp import YoutubeDL
      import sys
      import pprint
      
      import ffmpeg_downloader
      from ffmpeg_downloader import __main__ as ffdl
      
      def ffmpeg(upgrade=False):
          class arg:
              def __init__(self,upgrade):
                  self.upgrade = upgrade
              proxy = None
              retries = 5
              timeout = 15
              no_cache_dir = False
              force = False
              y = True
              add_path = True
              no_simlinks = False
              set_env = None
              reset_env = False
              presets = None
              version = &quot;snapshot@full&quot;
              func = ffdl.install
          pprint.pprint(arg.__dict__)
          ffdl.install(arg(upgrade))
      ffmpeg(upgrade=True)
      customtkinter.set_appearance_mode(&quot;Dark&quot;)
      
      ctypes.windll.shcore.SetProcessDpiAwareness(True)
      config = configparser.ConfigParser()
      
      class Config:
      
          def error(self):
              messagebox.showerror(&quot;KeyError&quot;,&quot;delete config file and restart again!&quot;)
              exit()
      
          def load(self):
              if not os.path.exists(&quot;./config.ini&quot;):
                  self.reset()
                  with open(&quot;config.ini&quot;,&quot;w&quot;,encoding=&apos;utf-8&apos;) as ini_file:
                      config.write(ini_file)
              config.read(&quot;config.ini&quot;,encoding=&apos;utf-8&apos;)
              data = {}
              for section in config.sections():
                  data[section] = {}
                  for option in config.options(section):
                      if any(x in section for x in [&quot;dl_options&quot;,&quot;app_options&quot;]):
                          data[section][option] = config.getboolean(section,option)
                      elif section in &quot;dl_channel&quot;:
                          data[section][option] = eval(config.get(section,option))
                      else:
                          data[section][option] = config.get(section,option)
              pprint.pprint(data)
              return data
          
          def save(self,event=None,exit_=False,reset=False):
              global config_data,meta,thumbnail,notification,dl_folder,uploader_folder,playlist_folder
              if not reset:
                  config_data = {
                      &quot;path&quot;:
                      {
                      &quot;main&quot;:output
                      },
                      &quot;dl_options&quot;:
                      {
                      &quot;meta&quot;:meta.get(),
                      &quot;thumbnail&quot;:thumbnail.get(),
                      &quot;notification&quot;:notification.get(),
                      &quot;dl_folder&quot;:dl_folder.get(),
                      &quot;uploader_folder&quot;:uploader_folder.get(),
                      &quot;playlist_folder&quot;:playlist_folder.get(),
                      },
                      &quot;app_options&quot;:
                      {
                      &quot;dl_latest&quot;:dl_latest,
                      &quot;exit&quot;:dl_latest_exit
                      },
                      &quot;codec&quot;:
                      {&quot;audio_codec&quot;:audio_codec.get(),
                      &quot;video_codec&quot;:video_codec.get(),
                      &quot;resolution&quot;:resolution.get()
                      },
                      &quot;dl_channel&quot;:
                      {
                      &quot;URL&quot;:dl_channel
                      }
                  }
              for section,options in dict(config_data).items():
                  config[section] = {}
                  for option,value in dict(options).items():
                      config[section][option] = str(value)
              with open(&apos;config.ini&apos;,&quot;w&quot;,encoding=&apos;utf-8&apos;) as ini_file:
                      config.write(ini_file)
              if exit_:
                  icon.stop()
                  root.destroy()
                  exit()
      
          def reset(self):
              global config_data
              config_data = {
                  &quot;path&quot;:
                  {
                  &quot;main&quot;:os.getcwd()
                  },
                  &quot;dl_options&quot;:
                  {
                  &quot;meta&quot;:False,
                  &quot;thumbnail&quot;:False,
                  &quot;notification&quot;:True,
                  &quot;dl_folder&quot;:True,
                  &quot;uploader_folder&quot;:True,
                  &quot;playlist_folder&quot;:True,
                  },
                  &quot;app_options&quot;:
                  {
                  &quot;dl_latest&quot;:False,
                  &quot;exit&quot;:True
                  },
                  &quot;codec&quot;:
                  {&quot;audio_codec&quot;:&quot;Auto&quot;,
                  &quot;video_codec&quot;:&quot;mp4&quot;,
                  &quot;resolution&quot;:&quot;Auto&quot;
                  },
                  &quot;dl_channel&quot;:
                  {
                  &quot;URL&quot;:&apos;[&quot;chanel URL 1&quot;,&quot;chanel URL 2&quot;]&apos;
                  }
                  }
              self.save(reset=True)
      
          def image(self):
              def run():
                  global win_icon,icon
                  win_icon = PIL.Image.open(io.BytesIO(requests.get(&quot;https://i.imgur.com/w5eKxTm.png&quot;,timeout=(5,5)).content))
                  root.iconphoto(True,PIL.ImageTk.PhotoImage(win_icon))
                  menu = pystray.Menu(
                      pystray.MenuItem(
                      &quot;Info&quot;,
                      &quot;v1.3&quot;
                      ),
                      pystray.MenuItem(
                      &quot;Jump To Homepage&quot;,
                      lambda:webbrowser.open(&quot;https://kurosiko.github.io/&quot;)
                      )
                  )
                  icon = pystray.Icon(&quot;Neural&quot;,icon=win_icon,menu=menu,title=&quot;VideoFetcher is running!&quot;)
                  icon.run()
              threading.Thread(target=run).start()
      
      class Gui:
      
          def __init__(self):
              self.current_frame = None
      
          def open_browser(self,URL):
              webbrowser.open(url=URL)
      
          def add_button(self, text=None, master=None, cmd=None, x=0, y=0, height=0.1, width=1,corner_radius=0,fg_color=&quot;transparent&quot;,anchor=tkinter.N):
              if master == None:
                  master = self.current_frame
              button = customtkinter.CTkButton(master=master, text=text, command=cmd,
                                              corner_radius=corner_radius, height=40,border_spacing=10,
                                              fg_color=fg_color,hover_color=(&quot;gray70&quot;, &quot;gray30&quot;),
                                              anchor=anchor)
              button.place(relx=x, rely=y, relheight=height, relwidth=width)
      
          def add_checkbox(self, text, master=None, x=0, y=0, height=0.1, width=1,val=None,text_color=&quot;black&quot;):
              if master == None:
                  master=self.current_frame        
              checkbox = customtkinter.CTkSwitch(master=master,text=text,command=func_config.save,fg_color=&quot;red&quot;,progress_color=&quot;green&quot;,text_color=text_color,variable=val)
              checkbox.place(relx=x, rely=y, relheight=height, relwidth=width)
      
          def add_weblink(self,text,x=0,y=0,height=0.1,width=1,cmd=None):
              button  = customtkinter.CTkButton(master=self.current_frame,text=text,command=cmd,text_color=&quot;#47bcf2&quot;,fg_color=&quot;transparent&quot;,corner_radius=0,hover_color=&quot;#dee6ff&quot;)
              button.place(relx=x,rely=y,relheight=height,relwidth=width)
              
          def create_setting_frame(self, title):
              f_root = customtkinter.CTkFrame(root,corner_radius=0,fg_color=&quot;white&quot;)
              f_root.place(relx=0.3, rely=0, relheight=1, relwidth=0.7)
              customtkinter.CTkLabel(f_root, text=title, fg_color=&quot;#444444&quot;, text_color=&quot;white&quot;).place(relx=0, rely=0, relheight=0.1, relwidth=1)
              return f_root
          
          def general(self):
              if self.current_frame is not None:
                  self.current_frame.destroy()
              self.current_frame = self.create_setting_frame(&quot;GENERAL&quot;)
      
              def browse():
                  global output
                  output_sub = filedialog.askdirectory()
                  if output_sub:
                      output = output_sub
                      Path_Label.configure(text=output)
                      
              Path_Label = customtkinter.CTkLabel(self.current_frame,text=output,text_color=&quot;black&quot;,anchor=tkinter.W)
              Path_Label.place(relx=0.05, rely=0.15, relheight=0.1, relwidth=0.65)
              self.add_button(text=&quot;Browse&quot;,cmd=browse,
                              fg_color=&quot;#444444&quot;,x=0.725,y=0.15,width=0.25)
              self.add_checkbox(text=&quot;DL Folder&quot;,x=0.05,y=0.3,val=dl_folder)
              self.add_checkbox(text=&quot;Uploader Folder&quot;,x=0.05,y=0.45,val=uploader_folder)
              self.add_checkbox(text=&quot;Playlist Folder&quot;,x=0.05,y=0.6,val=playlist_folder)
              self.add_checkbox(text=&quot;Notification&quot;,x=0.05,y=0.75,val=notification)
              self.add_button(text=&quot;Close&quot;,cmd=lambda:self.current_frame.destroy(),y=0.9,fg_color=&quot;#444444&quot;)
      
          def video(self):
              if self.current_frame is not None:
                  self.current_frame.destroy()
              self.current_frame = self.create_setting_frame(&quot;VIDEO&quot;)
              video_codec_list = [&quot;mp4&quot;,&quot;mkv&quot;,&quot;webm&quot;]
              video_resolution = [&quot;Auto&quot;,&quot;144p&quot;,&quot;240p&quot;,&quot;360p&quot;,&quot;480p&quot;,&quot;720p&quot;,&quot;1080p&quot;]
      
              customtkinter.CTkComboBox(master=self.current_frame,values=video_codec_list,command=func_config.save,variable=video_codec
                                      ).place(relx=0.05, rely=0.15, relheight=0.1, relwidth=0.9)
              customtkinter.CTkComboBox(master=self.current_frame,values=video_resolution,command=func_config.save,variable=resolution
                                      ).place(relx=0.05, rely=0.3, relheight=0.1, relwidth=0.9)
              self.add_button(text=&quot;Close&quot;,cmd=lambda:self.current_frame.destroy(),y=0.9,fg_color=&quot;#444444&quot;)
      
          def audio(self):
              if self.current_frame is not None:
                  self.current_frame.destroy()
              self.current_frame = self.create_setting_frame(&quot;AUDIO&quot;)
      
              audio_codec_list = [&quot;Auto&quot;,&quot;aac&quot;,&quot;flac&quot;,&quot;mp3&quot;,&quot;m4a&quot;,&quot;opus&quot;,&quot;vorbis&quot;,&quot;wav&quot;]
      
              customtkinter.CTkComboBox(master=self.current_frame,values=audio_codec_list,variable=audio_codec
                                      ).place(relx=0.05, rely=0.15, relheight=0.1, relwidth=0.9)
              self.add_checkbox(text=&quot;Meta Data&quot;,x=0.05,y=0.3,val=meta)
              self.add_checkbox(text=&quot;Thumbnail&quot;,x=0.05,y=0.45,val=thumbnail)
              self.add_button(text=&quot;Close&quot;,cmd=lambda:self.current_frame.destroy(),y=0.9,fg_color=&quot;#444444&quot;)
      
          def other(self):
              if self.current_frame is not None:
                  self.current_frame.destroy()
              self.current_frame = self.create_setting_frame(&quot;OTHER&quot;)
      
              self.add_weblink(text=&quot;WebPage&quot;,y=0.1,cmd=lambda:self.open_browser(URL=&quot;https://kurosiko.github.io/&quot;))
              self.add_weblink(text=&quot;FFmpeg&quot;,y=0.2,cmd=lambda:self.open_browser(URL=&quot;https://ffmpeg.org&quot;))
              self.add_weblink(text=&quot;Github&quot;,y=0.3,cmd=lambda:self.open_browser(URL=&quot;https://github.com/kurosiko/Kuros-VideoFetcher&quot;))
              self.add_weblink(text=&quot;Twitter&quot;,y=0.4,cmd=lambda:self.open_browser(URL=&quot;https://twitter.com/kurosiko&quot;))
              self.add_weblink(text=&quot;YouTube&quot;,y=0.5,cmd=lambda:self.open_browser(URL=&quot;https://www.youtube.com/channel/UCkbPdwURHuIG63f5ZTj3fjw&quot;))
              self.add_button(text=&quot;Close&quot;,cmd=lambda:self.current_frame.destroy(),y=0.9,fg_color=&quot;#444444&quot;)
      
          def auto(self):
              if self.current_frame is not None:
                  self.current_frame.destroy()
              self.current_frame = self.create_setting_frame(&quot;AUTO DOWNLOAD&quot;)
              self.add_button(text=&quot;Close&quot;,cmd=lambda:self.current_frame.destroy(),y=0.9,fg_color=&quot;#444444&quot;)
      
          def log(self):
              if self.current_frame is not None:
                  self.current_frame.destroy()
              sys.stdout.deiconify()
      
          def lunch(self):
              f_side = customtkinter.CTkFrame(root,corner_radius=0)
              f_side.place(relx=0, rely=0, relheight=1, relwidth=0.3)
              customtkinter.CTkLabel(f_side, text=&quot;SETTING&quot;, fg_color=&quot;black&quot;, text_color=&quot;white&quot;).place(relx=0, rely=0, relheight=0.1, relwidth=1)
      
              self.add_button(master=f_side,text= &quot;GENERAL&quot;, y=0.1, cmd=self.general,anchor=tkinter.E)
              self.add_button(master=f_side,text= &quot;VIDEO&quot;, y=0.2, cmd=self.video,anchor=tkinter.E)
              self.add_button(master=f_side,text= &quot;AUDIO&quot;, y=0.3, cmd=self.audio,anchor=tkinter.E)
              self.add_button(master=f_side,text= &quot;OTHER&quot;,y=0.4, cmd=self.other,anchor=tkinter.E)
              self.add_button(master=f_side,text= &quot;AUTO&quot;,y=0.5,cmd=self.log,anchor=tkinter.E)
              self.add_button(master=f_side,text= &quot;LOG&quot;,y=0.6,cmd=self.log,anchor=tkinter.E)
      
              self.add_checkbox(master=f_side,text=&quot;Playlist&quot;,x=0.05,y=0.7,val=playlist,text_color=&quot;white&quot;)
              self.add_checkbox(master=f_side,text=&quot;Audio Only&quot;,x=0.05,y=0.8,val=audio_only,text_color=&quot;white&quot;)
              threading.Thread(target=func_config.image).start()
      
      def dl_start(event=None,skip=False,URL=None):
          if not skip:
              URL = event.data or textbox.get()
              textbox.delete(0,tkinter.END)
          info = {}
          setting = {
              &apos;meta&apos;: meta.get(),
              &apos;thumbnail&apos;: thumbnail.get(),
              &apos;notification&apos;: notification.get(),
              &apos;dl_folder&apos;: dl_folder.get(),
              &apos;uploader_folder&apos;: uploader_folder.get(),
              &apos;playlist_folder&apos;: playlist_folder.get(),
              &apos;video_codec&apos;: video_codec.get(),
              &apos;audio_codec&apos;: audio_codec.get(),
              &apos;resolution&apos;:resolution.get(),
              &apos;playlist&apos;:playlist.get(),
              &apos;audio_only&apos;:audio_only.get(),
              &apos;audio_ext&apos;:{
                  &quot;aac&quot;:&quot;m4a&quot;,
                  &quot;flac&quot;:&quot;flac&quot;,
                  &quot;m4a&quot;:&quot;m4a&quot;,
                  &quot;mp3&quot;:&quot;mp3&quot;,
                  &quot;opus&quot;:&quot;opus&quot;,
                  &quot;vorbis&quot;:&quot;ogg&quot;,
                  &quot;wav&quot;:&quot;wav&quot;
              }
          }
      
          cancel = False
          
          progress = 0
          frame = customtkinter.CTkFrame(f_log,fg_color=&quot;black&quot;,height=50,corner_radius=0)
      
          l_playlist = customtkinter.CTkLabel(frame,anchor=tkinter.W,fg_color=&quot;#404040&quot;,text_color=&quot;#f7f7f8&quot;,corner_radius=0,text=None)
          l_playlist.place(relheight=0.4,relwidth=0.75)
      
          l_title = customtkinter.CTkLabel(frame,anchor=tkinter.W,fg_color=&quot;#333333&quot;,text_color=&quot;#f7f7f8&quot;,corner_radius=0,text=URL)
          l_title.place(relheight=0.4,relwidth=0.75,rely=0.4)
      
          l_playlist_index = customtkinter.CTkLabel(frame,anchor=tkinter.E,fg_color=&quot;#404040&quot;,text_color=&quot;#f7f7f8&quot;,corner_radius=0,text=None)
          l_playlist_index.place(relheight=0.4,relwidth=0.25,relx=0.75)
      
          l_progress = customtkinter.CTkLabel(frame,anchor=tkinter.E,fg_color=&quot;#333333&quot;,text_color=&quot;#f7f7f8&quot;,corner_radius=0,text=None)
          l_progress.place(relheight=0.4,relwidth=0.25,relx=0.75,rely=0.4)
      
          progressbar = customtkinter.CTkProgressBar(frame,corner_radius=0)
          progressbar.set(0)
          progressbar.place(relheight=0.2,relwidth=1,rely=0.8)
          frame.pack(fill=tkinter.X)
      
          def hook(data,URL=URL):
              if cancel:
                  return lambda:print(&quot;CANCEL&quot;)
              nonlocal info,progress
              if data[&apos;status&apos;] == &apos;downloading&apos;:
                  info[&apos;title&apos;] = data[&apos;info_dict&apos;][&apos;title&apos;]
                  try:
                      info[&apos;uploader&apos;] = data[&apos;info_dict&apos;][&apos;uploader&apos;]
                  except:
                      info[&apos;uploader&apos;] = data[&apos;info_dict&apos;][&apos;id&apos;]
                  if data[&apos;info_dict&apos;][&apos;playlist&apos;] is not None:
                      info[&apos;is_playlist&apos;] = True
                      info[&apos;playlist_title&apos;] = data[&apos;info_dict&apos;][&apos;playlist_title&apos;]
                      info[&apos;playlist_count&apos;] = data[&apos;info_dict&apos;][&apos;playlist_count&apos;]
                      info[&apos;playlist_index&apos;] = data[&apos;info_dict&apos;][&apos;playlist_index&apos;]
                      l_playlist.configure(text=info[&apos;playlist_title&apos;])
                      l_playlist_index.configure(text=f&quot;{info[&apos;playlist_index&apos;]}/{info[&apos;playlist_count&apos;]}&quot;)
                  else:
                      info[&apos;is_playlist&apos;] = False
                  try:
                      progress = math.floor(float(data[&apos;downloaded_bytes&apos;]/data[&apos;total_bytes&apos;])*100)/100
                  except:
                      try:
                          progress = math.floor(float(data[&apos;fragment_index&apos;]/data[&apos;fragment_count&apos;])*100)/100
                      except:
                          progress = progressbar.getint()
                  l_title.configure(text=info[&apos;title&apos;])
                  l_progress.configure(text=f&quot;{math.floor(progress*100)}%&quot;)
                  progressbar.set(progress)
              elif data[&apos;status&apos;] == &apos;finished&apos;:
                  l_title.configure(text=&apos;Exporting :D&apos;)
      
          def destory(is_error=False,URL=URL):
              try:
                  frame.destroy()
              except:
                  pass
              if setting[&apos;notification&apos;] or is_error:
                  def error():
                      nonlocal notification_opts
                      notification_opts.update({
                          &quot;title&quot;:&apos;ERROR&apos;,
                          &quot;body&quot;: URL,
                          &quot;button&quot;:{&apos;activationType&apos;: &apos;protocol&apos;, &apos;arguments&apos;:URL, &apos;content&apos;: &apos;Open URL&apos;}
                          }
                      )
                  notification_opts = {}
                  notification_opts[&apos;app_id&apos;] = &apos;VideoFetcher&apos;
                  notification_opts[&apos;duration&apos;] = &apos;short&apos;
                  try:
                      PIL.Image.open(io.BytesIO(requests.get(info[&apos;thumbnail&apos;],timeout=(10,10)).content)).save(&apos;thumbnail.png&apos;)
                      notification_opts[&apos;image&apos;] = {
                          &apos;src&apos;: os.path.join(os.getcwd(),&quot;thumbnail.png&quot;),
                          &apos;placement&apos;: &apos;hero&apos;
                      }
                  except:
                      pass
                  if is_error:
                      return error()
                  elif info[&apos;is_playlist&apos;]:
                      notification_opts.update({
                          &apos;title&apos;:info[&apos;title&apos;],
                          &apos;body&apos;:&apos;Finish download playlist!&apos;,
                          &apos;button&apos;:{&apos;activationType&apos;: &apos;protocol&apos;, &apos;arguments&apos;: info[&apos;path&apos;], &apos;content&apos;: &apos;Opef Folder&apos;}
                      })
                  elif info[&apos;title&apos;]:
                      notification_opts.update({
                          &quot;title&quot;:info[&apos;uploader&apos;],
                          &quot;body&quot;:info[&apos;title&apos;],
                          &quot;buttons&quot;:[
                          {&apos;activationType&apos;: &apos;protocol&apos;, &apos;arguments&apos;: info[&apos;path&apos;], &apos;content&apos;: &apos;Play&apos;},
                          {&apos;activationType&apos;: &apos;protocol&apos;,&apos;arguments&apos;:os.path.dirname(info[&apos;path&apos;]), &apos;content&apos;: &apos;Open Folder&apos;},
                          ]
                      })
                  else:
                      return error()
                  threading.Thread(target=win11toast.toast, kwargs=notification_opts).start()
      
          def dl(URL,setting=setting):
              nonlocal info
              output_dl = output
              ydl_opts = {}
              ydl_opts[&apos;ignoreerrors&apos;] = False
      
              if setting[&apos;dl_folder&apos;]:
                  output_dl = os.path.join(output_dl,&apos;dl_videos&apos;)
              if setting[&apos;uploader_folder&apos;]:
                  output_dl = os.path.join(output_dl,&apos;%(uploader)s&apos;)
              if not setting[&apos;playlist&apos;]:
                  ydl_opts[&apos;noplaylist&apos;] = True
              elif setting[&apos;playlist_folder&apos;] and setting[&apos;dl_folder&apos;]:
                  output_dl = os.path.join(output,&apos;dl_videos&apos;,&apos;Playlist&apos;,&apos;%(playlist)s&apos;)
              elif setting[&apos;playlist_folder&apos;] and not setting[&apos;dl_folder&apos;]:
                  output_dl = os.path.join(output,&apos;Playlist&apos;,&apos;%(playlist)s&apos;)
      
              ydl_opts[&apos;outtmpl&apos;] = os.path.join(output_dl,&apos;%(title)s.%(ext)s&apos;)
      
              if setting[&apos;audio_only&apos;]:
                  ydl_opts[&apos;format&apos;] = &quot;bestaudio&quot;
                  postprocessor = []
                  if not setting[&apos;audio_codec&apos;] == &quot;Auto&quot;:
                      postprocessor.append({&apos;key&apos;: &apos;FFmpegExtractAudio&apos;,&apos;preferredcodec&apos;:setting[&apos;audio_codec&apos;]})
                  if setting[&apos;meta&apos;] and not any(x in setting[&apos;audio_codec&apos;] for x in [&quot;aac&quot;,&quot;vorbis&quot;,&quot;wav&quot;]):
                      postprocessor.append({&apos;key&apos;: &apos;FFmpegMetadata&apos;})
                  if setting[&apos;thumbnail&apos;] and any(x in setting[&apos;audio_codec&apos;] for x in [&quot;m4a&quot;,&quot;mp3&quot;]):
                      ydl_opts[&apos;writethumbnail&apos;] = True
                      postprocessor.append({&apos;key&apos;: &apos;EmbedThumbnail&apos;,&apos;already_have_thumbnail&apos;: False})
                  if postprocessor:
                      ydl_opts[&apos;postprocessors&apos;] = postprocessor
              else:
                  if setting[&apos;resolution&apos;] == &apos;Auto&apos;:
                      ydl_opts[&apos;format&apos;] = &quot;bv+ba[ext=m4a]/bv+ba/b&quot;
                  else:
                      ydl_opts[&apos;format&apos;] = f&quot;bv[height={str(setting[&apos;resolution&apos;]).replace(&apos;p&apos;,&apos;&apos;)}]+ba[ext=m4a]/bv+ba[ext=m4a]/b&quot;
                  if setting[&apos;video_codec&apos;] != &quot;webm&quot;:
                      ydl_opts[&apos;merge_output_format&apos;] = setting[&apos;video_codec&apos;]
      
              ydl_opts[&apos;progress_hooks&apos;] = [hook]
              try:
                  with YoutubeDL(ydl_opts) as ydl:
                      try:
                          data = ydl.extract_info(URL,download=True)
                      except:
                          return destory(is_error=True)
                      else:
                          print(&quot;\033[32m&quot;+&quot;DL&quot;+&quot;\033[0m&quot;)
                      info[&apos;path&apos;] = ydl.prepare_filename(data)
                  info[&apos;title&apos;] = data[&apos;title&apos;]
                  info[&apos;uploader&apos;] = data[&apos;uploader&apos;]
                  if &apos;_type&apos; in data and data[&apos;_type&apos;] == &apos;playlist&apos;:
                      info[&apos;is_playlist&apos;] = True
                      info[&apos;thumbnail&apos;] = data[&apos;entries&apos;][0][&apos;thumbnail&apos;]
                      info[&apos;path&apos;] = data[&apos;entries&apos;][0][&apos;requested_downloads&apos;][0][&apos;__finaldir&apos;]
                  else:
                      info[&apos;is_playlist&apos;] = False
                      info[&apos;thumbnail&apos;] = data[&apos;thumbnail&apos;]
                  if setting[&apos;audio_only&apos;] and not setting[&apos;audio_codec&apos;] == &apos;Auto&apos;:
                      info[&apos;path&apos;] = f&quot;{os.path.splitext(info[&apos;path&apos;])[0]}.{setting[&apos;audio_ext&apos;][setting[&apos;audio_codec&apos;]]}&quot;
              except:
                  return destory(is_error=True)
              else:
                  print(&quot;\033[32m&quot;+&quot;ok&quot;+&quot;\033[0m&quot;)
              return destory()
          thread = threading.Thread(target=dl,args=(URL,))
          thread.start()
          return thread
      
      def dl_ch():
          if dl_latest:
              for url in dl_channel:
                  if isinstance(url,dict):
                      if list(dict(url).values())[0]:
                          audio_only.set(True)
                      url = list(dict(url).keys())[0]
                      thread = dl_start(URL=url,skip=True)
                      thread.join()
                      audio_only.set(False)
                  else:
                      pass
              if dl_latest_exit:
                  func_config.save(exit_=True)
      
      class CustomLog(tkinter.Toplevel):
          def __init__(self, master):
              super().__init__(master)
              self.title(&quot;Log&quot;)
              self.geometry(&quot;600x480&quot;)
              self.configure(bg=&quot;#242424&quot;)
              self.minsize(600, 480)
              self.attributes(&apos;-topmost&apos;, True)
              self.protocol()
              self.log = tkinter.Text(self)
              self.log.pack(fill=tkinter.BOTH)
              self.protocol(&quot;WM_DELETE_WINDOW&quot;,lambda:self.withdraw())
      
          def write(self, string):
              self.log.insert(tkinter.END, f&quot;{string}\n&quot;)
              self.log.see(tkinter.END)
      
          def flush(self):
              pass
      
      func_config = Config()
      config_data = func_config.load()
      func_gui = Gui()
      
      root = tkinterdnd2.Tk()
      root.drop_target_register(tkinterdnd2.DND_TEXT)
      def titlebar(window):#By Unnamedbuthere_
        window.update()
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20
        set_window_attribute = ctypes.windll.dwmapi.DwmSetWindowAttribute
        get_parent = ctypes.windll.user32.GetParent
        hwnd = get_parent(window.winfo_id())
        rendering_policy = DWMWA_USE_IMMERSIVE_DARK_MODE
        value = 3
        value = ctypes.c_int(value)
        set_window_attribute(hwnd,rendering_policy,ctypes.byref(value),ctypes.sizeof(value))
      titlebar(root)
      
      try:
          output = config_data[&quot;path&quot;][&quot;main&quot;]
          dl_latest = config_data[&quot;app_options&quot;][&quot;dl_latest&quot;]
          dl_latest_exit = config_data[&quot;app_options&quot;][&quot;exit&quot;]
          dl_channel = config_data[&quot;dl_channel&quot;][&quot;url&quot;]
          meta = tkinter.BooleanVar(value=config_data[&quot;dl_options&quot;][&quot;meta&quot;])
          thumbnail = tkinter.BooleanVar(value=config_data[&quot;dl_options&quot;][&quot;thumbnail&quot;])
          notification = tkinter.BooleanVar(value=config_data[&quot;dl_options&quot;][&quot;notification&quot;])
          dl_folder = tkinter.BooleanVar(value=config_data[&quot;dl_options&quot;][&quot;dl_folder&quot;])
          uploader_folder = tkinter.BooleanVar(value=config_data[&quot;dl_options&quot;][&quot;uploader_folder&quot;])
          playlist_folder = tkinter.BooleanVar(value=config_data[&quot;dl_options&quot;][&quot;playlist_folder&quot;])
          resolution = tkinter.StringVar(value=config_data[&quot;codec&quot;][&quot;resolution&quot;])
          audio_codec = tkinter.StringVar(value=config_data[&quot;codec&quot;][&quot;audio_codec&quot;])
          video_codec = tkinter.StringVar(value=config_data[&quot;codec&quot;][&quot;video_codec&quot;])
      except:
          func_config.error()
      
      sys.stdout = CustomLog(root)
      sys.stdout.withdraw()
      
      print(&quot;Log Strat&quot;)
      
      root.title(&quot;VideoFetcher&quot;)
      root.geometry(&quot;600x480&quot;)
      root.configure(bg=&quot;#242424&quot;)
      root.minsize(600,480)
      root.attributes(&apos;-topmost&apos;,True)
      root.dnd_bind(&apos;&lt;&lt;Dropgt;gt;&apos;,dl_start)
      
      textbox = customtkinter.CTkEntry(root,placeholder_text=&quot;Enter URL&quot;)
      textbox.place(relx=0.35,rely=0.05,relwidth=0.6)
      textbox.bind(&quot;&lt;Returngt;&quot;,dl_start)
      
      playlist = tkinter.BooleanVar(value=False)
      audio_only  = tkinter.BooleanVar(value=False)
      
      f_log = customtkinter.CTkFrame(root,corner_radius=5)
      f_log.place(relx=0.35,rely=0.2,relwidth=0.6,relheight=0.75)
      
      func_gui.lunch()
      
      root.after(1000,lambda:threading.Thread(target=dl_ch,daemon=True).start())
      
      root.protocol(&quot;WM_DELETE_WINDOW&quot;,lambda:func_config.save(exit_=True))
      root.update()
      root.mainloop()
    </code>
    </pre>
  </body>
</html>
